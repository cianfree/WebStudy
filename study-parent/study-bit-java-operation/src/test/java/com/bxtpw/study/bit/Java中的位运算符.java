package com.bxtpw.study.bit;

/**
 * <pre>
 * 位运算表达式由操作数和位运算符组成，实现对整数类型的二进制数进行位运算。位运算符可以分为逻辑运算符(包括~、＆、|和^)及移位运算符(包括>>、<<和>>>)。
 *
 * 1)左移位运算符（<<）能将运算符左边的运算对象向左移动运算符右侧指定的位数（在低位补0）。
 * 2)“有符号”右移位运算符（>>）则将运算符左边的运算对象向右移动运算符右侧指定的位数。
 * “有符号”右移位运算符使用了“符号扩展”：若值为正，则在高位插入0；若值为负，则在高位插入1。
 *
 * 3)Java也添加了一种“无符号”右移位运算符（>>>），它使用了“零扩展”：无论正负，都在高位插入0。这一运算符是C或C++没有的。
 *
 * 4)若对char，byte或者short进行移位处理，那么在移位进行之前，它们会自动转换成一个int。
 * 只有右侧的5个低位才会用到。这样可防止我们在一个int数里移动不切实际的位数。
 * 若对一个long值进行处理，最后得到的结果也是long。此时只会用到右侧的6个低位，防止移动超过long值里现成的位数。
 * 但在进行“无符号”右移位时，也可能遇到一个问题。若对byte或short值进行右移位运算，得到的可能不是正确的结果（Java 1.0和Java 1.1特别突出）。
 * 它们会自动转换成int类型，并进行右移位。但“零扩展”不会发生，所以在那些情况下会得到-1的结果。
 *
 * 在进行位运算时，需要注意以下几点。
 * 　　(1)>>>和>>的区别是：在执行运算时，>>>运算符的操作数高位补0，而>>运算符的操作数高位移入原来高位的值。
 * 　　(2)右移一位相当于除以2，左移一位(在不溢出的情况下)相当于乘以2；移位运算速度高于乘除运算。
 * 　　(3)若进行位逻辑运算的两个操作数的数据长度不相同，则返回值应该是数据长度较长的数据类型。
 * 　　(4)按位异或可以不使用临时变量完成两个值的交换，也可以使某个整型数的特定位的值翻转。
 * 　　(5)按位与运算可以用来屏蔽特定的位，也可以用来取某个数型数中某些特定的位。
 * 　　(6)按位或运算可以用来对某个整型数的特定位的值置l。
 *
 * 位运算符的优先级
 * 　~的优先级最高，其次是<<、>>和>>>，再次是＆，然后是^，优先级最低的是|。
 * </pre>
 *
 * @author 夏集球
 * @version 0.1
 * @time 2015/12/16 19:59
 * @since 0.1
 */
public class Java中的位运算符 {
}
