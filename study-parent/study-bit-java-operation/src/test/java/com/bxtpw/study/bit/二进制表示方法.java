package com.bxtpw.study.bit;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * <pre>
 * Java中的二进制表示方法
 * 在Java语言中，二进制数使用补码表示，最高位为符号位，正数的符号位为0，负数为1。补码的表示需要满足如下要求。
 * 　(l) 正数的最高位为0，其余各位代表数值本身(二进制数)。
 * 　(2) 对于负数，通过对该数绝对值的补码按位取反（包括符号位，0变1，1变0），再对整个数加1。
 * </pre>
 *
 * @author 夏集球
 * @version 0.1
 * @time 2015/12/16 19:42
 * @since 0.1
 */
public class 二进制表示方法 {

    @Test
    public void test正数Int类型表示法() {
        // 与原码表示法相同，正数的最高位为0，其余各位代表数值本身(二进制数)。
        // 整型是32位
        // 00000000 00000000 00000000 00000000 == 0
        assertEquals(0, 0b00000000000000000000000000000000);

        // 00000000 00000000 00000000 00000001 == 1
        assertEquals(1, 0b00000000000000000000000000000001);
    }

    @Test
    public void test负数Int类型表示法() {
        // 对于负数，通过对该数绝对值的补码按位取反（包括符号位，0变1，1变0），再对整个数加1。
        // 例如： 求-5的补码。
        // -5对应正数5（00000000 00000000 00000000 00000101）→
        // 所有位取反（11111111 11111111 11111111 11111010）→ 加1(11111111 11111111 11111111 11111011)
        // 所以-5的补码是11111111 11111111 11111111 11111011。
        // 即 -5 == 11111111 11111111 11111111 11111011
        assertEquals(-5, 0b11111111111111111111111111111011);

        // 例如： 求-1的补码。
        // -1对应正数1（00000000 00000000 00000000 00000001）→
        // 所有位取反（11111111 11111111 11111111 11111110）→ 加1(11111111 11111111 11111111 11111111)
        // 所以-1的补码是11111111 11111111 11111111 1111111。
        // 即 -1 == 11111111 11111111 11111111 11111111
        assertEquals(-1, 0b11111111111111111111111111111111);
    }
}
